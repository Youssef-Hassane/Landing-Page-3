<!DOCTYPE >
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Manipulating the DOM</title>
  <!-- Load Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Fira+Sans:900|Merriweather&display=swap" rel="stylesheet">  <!-- Load Styles -->
  <link href="css/styles.css" rel="stylesheet">
</head>
<body>
  <!-- HTML Follows BEM naming conventions 
  IDs are only used for sections to connect menu achors to sections -->
  <header class="page__header">
    <nav class="navbar__menu">
      <!-- Navigation starts as empty UL that will be populated with JS -->
      <ul id="navbar__list"></ul>
    </nav>
  </header>
  <main>
    <header class="main__hero">
      <h1>Landing Page </h1>
    </header>
    <!-- Each Section has an ID (used for the anchor) and 
    a data attribute that will populate the li node.
    Adding more sections will automatically populate nav.
    The first section is set to active class by default -->
    <section id="section1" data-nav="Section 1" class="your-active-class">
      <div class="landing__container">
        <h2>Section 1 (Virtualization And Virtual Machines)</h2>
        <p>Discuss How Operating Systems Use A General Technique Called Virtualization And Virtual Machines:</p>
        <p>In order to answer the discussion assignment question, I'm going to discuss with you two concepts: which are hardware and system software. As we all know a computer consists of two things hardware and software. Hardware is the physical components such as Central Processing Unit (CPU), Graphics Processing Unit (GPU), Random Access Memory (RAM), Network Interface Card (NIC), Storage (SDD or HDD), etc., but the hardware on its own is pretty hard to use for a regular person like you and me that is where system software (operating system) comes in. System software (operating system) is what makes a computer easy to use. Windows, Mac OS, and Linux are examples of operating systems.</p>
        <p>Now, let's talk about virtualization according to Brush and Kirsch (2019), "Virtualization is the creation of a virtual -- rather than actual -- version of something, such as an operating system (OS), a server, a storage device or network resources" (para. 1). In other words, virtualization means creating a virtual version of some software that is able to function as if it were installed on the physical hardware. When it comes to operating systems, virtualization happens by a computer software called a hypervisor which also known as a virtual machine monitor (VMM). A hypervisor is computer software that creates and runs virtual machines. In detail, a hypervisor is a software program that runs on the host hardware and oversees the implementation of guest operating systems on virtual machines (Firesmith, 2017). </p>
        <p>According to Firesmith (2017), there are two types of a hypervisor, the first one is called type 1 hypervisor (or native hypervisor), and the second one is called type 2 hypervisor (or hosted hypervisor). Look at the screenshot below to see the difference between them.</p>
        <p>Now, let’s talk about the virtual machine (VM), a virtual machine (VM) which also known as a guest machine, is a virtual environment that functions as a virtual computer system with its own CPU, GPU, RAM, NIC, storage (SSD or HDD), etc., that is created on a physical hardware system and hypervisor separates the machine’s resources from the hardware and provisions them appropriately so they can be used, by the virtual machine (VM) (Firesmith, 2017; Bovey, 2019). </p>
        <p>What are the reasons that may make an individual user or an organization want to create a virtual machine? There are many reasons, but I'm going to mention two of them. The first reason is that it will allow the user to run applications that might not run with the operating system (OS) that they have. For example, the user might have a macOS, and they want to download an application that only can run on windows. The second reason is that an individual user or an organization might want to test an application, but at the same time they don’t want any harm to their host operating system (Bovey, 2019).</p>
        <p>In the end, virtualization is a technology that focuses on dividing the hardware of a computer (resources), such as CPU, GPU, RAM, NIC, Storage (SDD or HDD), etc., so that each part of it can operate software in such a way that it delivers the illusion that it is a completely independent system that has its separate resources, and all that is to enable the user to operate two or more systems running simultaneously on the same computer, not just that it also allows the same computer to be used by multiple users at the same time.</p>
        <p>References</p>
        <p>Bovey, V [IBM Cloud]. (2019, March 28). Virtualization Explained [Video]. YouTube. <a href="https://www.youtube.com/watch?v=FZR0rG3HKIk">Click Here</a></p>
        <p>Brush, K., & Kirsch, B. (2019, October 30). What is Virtualization and How Does it Work? Retrieved from <a href="https://searchservervirtualization.techtarget.com/definition/virtualization">Click Here</a></p>
        <p>Firesmith, D. (2017, September 18). Virtualization via Virtual Machines. Retrieved from <a href="https://insights.sei.cmu.edu/sei_blog/2017/09/virtualization-via-virtual-machines.html">Click Here</a></p>
        <p style="color: red">The previous was written by Youssef Hassane, 31 January 2021</p>
      </div>
    </section>
    <section id="section2" data-nav="Section 2">
      <div class="landing__container">
        <h2>Section 2 (Virtualizing The CPU)</h2>
        <p>How OS creates the illusion of virtualization by virtualizing the CPU:</p>
        <p>In order to answer this week's discussion assignment question, let's take a look at what we discussed last week. So, last week we have talked about virtualization and the virtual machine, and we knew that "Virtualization is the creation of a virtual -- rather than actual -- version of something, such as an operating system (OS), a server, a storage device or network resources" (Brush & Kirsch, 2019, para. 1). This week we will talk about a type of virtualization, which is virtualizing the CPU, and how the Operating System (OS) creates the illusion of virtualization by virtualizing the CPU. </p>
        <p>First of all, what is the CPU? CPU is an acronym for Central Processing Unit. In short, the CPU is the brain of the computer, and everything the user does on the computer goes through the CPU. Now, let’s answer the discussion question, how the Operating System (OS) creates the illusion of virtualization by virtualizing the CPU? Nowadays, most operating systems are using virtualization to manage the CPU and other resources that are available in the computer. More specifically, the operating system creates the illusion of virtualization by using a method called time-sharing of the CPU, and by using the time-sharing method it allows the users to run multiple processes (programs) simultaneously. That means the CPU is being used for a while by an individual program and then used for a while by another individual program and so forth. So by using the time-sharing method, the CPU won't be in sleep mode. Therefore, it will keep the CPU working, reduced waiting time, and saving energy (Arpaci-Dusseau & Arpaci-Dusseau, 2012).</p>
        <p>Let's assume that on your computer, you are running Microsoft word to do your assignment, Google Chrome with many windows in order to find the information that you are looking for, Visual studio code or Clion for coding, and you playing music on Spotify. It should be noted that a single CPU can only run one program (process) at a time, and this is not what you want, right? You want all these programs to run at the same time. Therefore, the operating system needs to create the illusion of virtualization by virtualizing the CPU. How? "By running one process, then stopping it and running another, and so forth, the OS can promote the illusion that many virtual CPUs exist when in fact there is only one physical CPU (or a few)" (Arpaci-Dusseau & Arpaci-Dusseau, 2012, p. 1). In other words, it all lies in managing the time between the programs and keep tracking those programs when it goes to get information, for example, from Input/Output (I/O). Through these times of waiting, the CPU goes to execute other programs while waiting for the input. But there is a consequence or cost when running many programs simultaneously, which is the performance of the CPU. Since the CPU must be shared, each program will run slowly (Arpaci-Dusseau & Arpaci-Dusseau, 2012). That is how time-sharing is work, and to make things easier, look at the below diagram:</p>
        <p>According to Arpaci-Dusseau & Arpaci-Dusseau (2012), "To implement virtualization of the CPU, and to implement it well, the OS will need both some low-level machinery and some high-level intelligence" (p. 1). The low-level machinery is known as mechanisms, and the high-level intelligence is known as policies. What's the difference between mechanisms and policies? According to Arpaci-Dusseau & Arpaci-Dusseau (2012), mechanisms are low-level methods that implement a needed piece of functionality. For example, the context switch, which gives the operating system (OS) the ability to stop running a program and start running another one. While on the other hand, policies are algorithms for settling on some sort of decision inside the operating system (OS) (Arpaci-Dusseau & Arpaci-Dusseau, 2012).</p>
        <p>References</p>
        <p>Arpaci-Dusseau, R. & Arpaci-Dusseau, A. (2012). Operating systems: Three easy pieces. Madison, WI: University of Wisconsin-Madison. Retrieved from <a href="https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf">Click Here</a></p>
        <p>Brush, K., & Kirsch, B. (2019, October 30). What is Virtualization and How Does it Work? Retrieved February 7, 2021, from <a href="https://searchservervirtualization.techtarget.com/definition/virtualization">Click Here</a></p>
        <p style="color: red">The previous was written by Youssef Hassane, 7 February 2021</p>

      </div>
    </section>
    <section id="section3" data-nav="Section 3">
      <div class="landing__container">
        <h2>Section 3 (Switch Between Processes)</h2>
        <p>Discuss how operating systems, Switch Between Processes And/or how the OS decides to stop one process and start another:</p>
        <p>In order to answer this week's discussion assignment question, let's take a look at what we discussed last week. Last week we discussed how the operating system (OS) creates the illusion of virtualization by virtualizing the CPU, and we have talked about the time-sharing method. We said that the operating system creates the illusion of virtualization by using a method called time-sharing of the CPU, and by using the time-sharing method, it allows the users to run multiple processes (programs) simultaneously. This week we will discuss how operating systems switch between processes and how the operating system (OS) decides to stop one process and start another.</p>
        <p>Additionally, last week we learned about the low-level machinery, which is known as mechanisms. According to Arpaci-Dusseau & Arpaci-Dusseau (2012), mechanisms are low-level methods that implement a needed piece of functionality. For example, the context switch, which gives the operating system (OS) the ability to stop running a program and start running another one. This week we have learned about high-level intelligence, which is known as policies. What do policies mean? In short, policies are algorithms for settling on some sort of decision inside the operating system (OS) (Arpaci-Dusseau & Arpaci-Dusseau, 2012). </p>
        <p>I'm going first to discuss the second question, which is how the OS decides to stop one process and start another, to determine some terms. The operating system decides to stop one process and start another by scheduler depending on the policies (high-level intelligence) that the operating system (OS) has. Now, if we said that the scheduling is based on a Multi-Level Feedback Queue (MLFQ) when the operating system takes a decision, it keeps in consideration the turnaround and response time metrics. According to Arpaci-Dusseau & Arpaci-Dusseau (2012), the MLFQ uses five rules in order to guide or takes the decision:</p>
        <p>"Rule 1: If Priority(A) > Priority(B), A runs (B doesn’t). Rule 2: If Priority(A) = Priority(B), A & B run in round-robin fashion using the time slice (quantum length) of the given queue. Rule 3: When a job enters the system, it is placed at the highest priority (the topmost queue). Rule 4: Once a job uses up its time allotment at a given level (regardless of how many times it has given up the CPU), its priority is reduced (i.e., it moves down one queue). Rule 5: After some time period S, move all the jobs in the system to the topmost queue." (Arpaci-Dusseau & Arpaci-Dusseau, 2012, Ch. 8, p. 10).</p>
        <p>With that being said, the operating system (OS) will decide which process should stop and which process should start, based on the effectiveness (priority) of the jobs. That means the jobs that are more effective will run, and vice versa (Arpaci-Dusseau & Arpaci-Dusseau, 2012). On the other hand, if the operating system (Linux) is using the proportional-share scheduler, its goal is to be fairer and to ensure a certain percentage of CPU usage to each job. The operating system (Linux) uses some tools like Completely Fair Scheduler (CFS) to decide which process should stop and which process should start. Completely Fair Scheduler or (CFS) is using a simple counting-based technique known as virtual runtime or (vruntime) in order to organize which process should be running and which should be stopped. The CFS will pick the process with the lowest vruntime to run. It will allow the users to set priority, which helps the operating system (OS) to determine which process should run the most. Also, CFS controls the maximum/minimum amount of time the process should be running (Arpaci-Dusseau & Arpaci-Dusseau, 2012). Keep in mind that there are types of schedulers, which are the Long term, Mid-term, and Short term (AfterAcademy, 2019).</p>
        <p>As for the first question, if the operating systems (OS) (scheduler) decides to switch between processes, the operating system is going to run low-level mechanisms for context switching. Context switching will store the context (State) like registers, program counter, and the kernel stack pointer of the process so that it can be reloaded when required, and the execution can be resumed from the same point as earlier. Then, it’s going to get the stored context (State) of the new process to run it (Arpaci-Dusseau & Arpaci-Dusseau, 2012). If you felt confused, look at the below diagram:</p>
        <p>References</p>
        <p>AfterAcademy. (2019). What is Long-Term, short-term, and MEDIUM-TERM SCHEDULER? Retrieved February 16, 2021, from <a href="https://afteracademy.com/blog/what-is-long-term-short-term-and-medium-term-scheduler">Click Here</a></p>
        <p>Arpaci-Dusseau, R. & Arpaci-Dusseau, A. (2012). Operating systems: Three easy pieces. Madison, WI: University of Wisconsin-Madison. Retrieved from <a href="https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf">Click Here</a></p>
        <p>Sumeet, S. (n.d.). Operating system- processes - powerpoint slides. Retrieved February 16, 2021, from <a href="https://www.learnpick.in/prime/documents/ppts/details/47/operating-system-processes">Click Here</a></p>
        <p style="color: red">The previous was written by Youssef Hassane, 15 February 2021</p>
      </div>
    </section>
    <section id="section4" data-nav="Section 4">
      <div class="landing__container">
        <h2>Section 4 (The Latest Advances in Memory Management)</h2>
        <p>Discuss the Latest Advances in Memory Management to Include the Use of Tables and Memory Swapping From Memory to Disk:</p>
        <p>In order to answer the discussion assignment question, I'm going to discuss with you some concepts: which are Virtual Memory, Page Tables, and Swapping. Virtual memory management is a technique that usage paging tables and swapping approaches in order to manage memory space to optimize performance. “Virtual memory is an elegant interaction of hardware exceptions, hardware address translation, main memory, disk files, and kernel software that provides each process with a large, uniform, and private address space” (Virtual Memory, n.d., p.776). In other words, virtual memory is a memory management technique that is realized on both the operating system (OS) and memory management unit (MMU), which is a hardware chip. It is used when there is a program that is going to be executed, and it requires a large space larger than that available in the physical memory. So the operating system (OS) saves the processes on the disk by using a technique called Paging. Also, it gives each process the illusion that it has its own physical memory.</p>
        <p>Memory swapping is an important technique that the operating system uses in a situation where there are multiple processes are running on the CPU simultaneously, and those processes need to be stored on the physical memory. So memory swapping technique enables the operating system (OS) to move the entire process from the memory to the secondary storage (disk) and fetch it back again as the need arises. Keep in mind that the process that moved in the secondary memory (Disk) are the ones that are rarely used. All that in order to provide more memory than the physical memory has to a run more process, without the need of killing (end) some processes. That means when the operating system sees that there is no space left in the physical memory, it uses the memory swapping technique to get additional memory (Arpaci-Dusseau & Arpaci-Dusseau, 2012; Kerner, 2019; Simple Snippets, 2018). "Writing pages out to disk is a relatively slow process (compared to the speed of the CPU and the main memory), however it is a better option than just crashing or killing off processes. The process of writing pages out to disk to free memory is called swapping-out. If later a page fault is raised because the page is on disk, in the swap area rather than in memory, then the kernel will read back in the page from the disk and satisfy the page fault. This is swapping-in" (Breaker, 2019, para. 21-22).</p>
        <p>The page table is a data structure that stores the mapping between virtual and physical addresses and is managed by the operating system (OS). Where is the page table stored? The page table is stored in the memory, meaning the more processes running, the more memory is used. The page table gets updated in order to represent the physical location of swapped data on the drive (Hard Disk). When the operating system (OS) fetches the data, it gets back to the physical memory, and again the page table gets updated. With that being said, the page tables play an important role in swapping due to the fact that it stores the mapping between virtual and physical addresses (Arpaci-Dusseau & Arpaci-Dusseau, 2012; Tolomei, 2013). Additionally, there are bits stored in the page table that inform the operating system (OS) if the page requested is in the primary (main) or the secondary memory.</p>
        <p>References</p>
        <p>Arpaci-Dusseau, R. H., & Arpaci-Dusseau, A. C. (2012). Operating Systems: Three Easy Pieces, Chapters 18-20. Madison, WI: Arpaci-Dusseau Books. Retrieved from <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/">Click Here</a></p>
        <p>Breaker, D. (2019, September 13). Understanding page faults and memory swap-in/outs: when should you worry?: Scout APM Blog. Scout. <a href="https://scoutapm.com/blog/understanding-page-faults-and-memory-swap-in-outs-when-should-you-worry">Click Here</a></p>
        <p>Kerner, S. M. (2019, August 8). What is Memory Swapping? Retrieved from <a href="https://www.enterprisestorageforum.com/hardware/what-is-memory-swapping/">Click Here</a></p>
        <p>Simple Snippets. (2018, September 10). Paging in Operating Systems with Example & Working - Memory Management [Video]. YouTube. <a href="https://www.youtube.com/watch?v=pJ6qrCB8pDw&t=74s">Click Here</a></p>
        <p>Tolomei, G. (2013, October 31). Virtual Memory, Paging, and Swapping. Retrieved from <a href="https://gabrieletolomei.wordpress.com/miscellanea/operating-systems/virtual-memory-paging-and-swapping/">Click Here</a></p>
        <p>Virtual Memory. (n.d.). Retrieved March 8, 2021, from <a href="http://zacharski.org/files/courses/cs405/computerSystemsChapter9.pdf">Click Here</a></p>
        <p style="color: red">The previous was written by Youssef Hassane, 8 March 2021</p>
      </div>
    </section>
    <section id="section5" data-nav="Section 5">
      <div class="landing__container">
        <h2>Section 5 (Reduce the Cost of Paging)</h2>
        <p>Discuss How to Reduce the Cost of Paging to Disk Because Frequent Paging is Prohibitive:</p>
        <p>In order to answer this week's discussion assignment question, let's take a look at what we discussed last week. So, last week we have learned that having the process in the memory is more efficient and faster than having it on the secondary storage disk. But when there is no space in the memory, the solution is swapping (paging) some processes into the secondary storage (disk). We also learned that memory swapping (paging) is an important technique that the operating system uses in a situation where there are multiple processes are running on the CPU simultaneously, and those processes need to be stored on the physical memory. So memory swapping (paging) technique enables the operating system (OS) to move the entire process from the memory to the secondary storage (disk) and fetch it back again as the need arises. All that in order to provide more memory than the physical memory has to a run more process, without the need of killing (end) some processes. That means when the operating system sees that there is no space left in the physical memory, it uses the memory swapping (paging) technique to get additional memory (Arpaci-Dusseau & Arpaci-Dusseau, 2012; Kerner, 2019; Simple Snippets, 2018). Memory swapping (paging) has a negative impact on performance. Because if there is a page that is being used often is being swapped from the primary (main) storage to the secondary storage (disk), and then get fetch to the primary (main) storage, the user experience will not be smooth.</p>
        <p>I believe that there are three main options that we can use in order to reduce the cost of paging to disk since frequent paging is prohibitive. Those options are some page-replacement policy (algorithms), upgrading the disk, and finally upgrading the memory. Let's start with the page-replacement policy (algorithms). Developers have implemented policies (algorithms). Those policies (algorithms) are; the "Optimal" algorithm, First-In-First-Out (FIFO), Random, and Least Recently Used (LRU). However, the "Optimal" algorithm can’t be used due to the fact that it's impossible to implement. We just use the "Optimal" algorithm to compare the other policies (algorithms). Why? Because the "Optimal" algorithm depends on predicting the future, and we can't do that. Therefore, the "Optimal" algorithm is only used for comparing with other policies in order to know how well other algorithms perform (Arpaci-Dusseau & Arpaci-Dusseau, 2012). Now, I'm going to talk about those policies briefly:</p>
        <p>1. First-In-First-Out (FIFO):</p>
        <p>The First-In-First-Out (FIFO) policy works by swapping out the oldest page in the memory to the secondary storage (disk) in order to free space for a new page without taking any historical data into account. The issue (problem) with this policy is that the oldest page could be the most used page and due to the fact that FIFO doesn't take any historical data into account. Therefore, it could swap the page to the secondary storage (disk) right after fetching it right back. That means that FIFO is not close to the "Optimal" algorithm (Arpaci-Dusseau & Arpaci-Dusseau, 2012).</p>
        <p>2. Random:</p>
        <p>The Random policy is not actually an algorithm because it works by randomly choose any page from the primary storage (memory) and swapping it to the secondary storage (disk). Also, it doesn't take any historical data into account. With that being said, the Random policy usually performs from great to poor. But sometimes, it outperforms both First-In-First-Out (FIFO) and Least Recently Used (LRU) algorithms. In short, the Random policy depends on luck (Arpaci-Dusseau & Arpaci-Dusseau, 2012).</p>
        <p>3. Least Recently Used (LRU):</p>
        <p>The Least Recently Used (LRU) policy is the only algorithm that uses the historical data into account in order to know which pages have been used recently and chooses one that has not been used for a while. Meaning that if the page has been used recently, there is a big chance that it will be used again. So, the best choice is to keep that page in the primary storage (memory). Additionally, the LRU uses the clock algorithm (Arpaci-Dusseau & Arpaci-Dusseau, 2012).</p>
        <p>* Upgrading The Disk (from HDD to SDD):</p>
        <p>Let's compare the speed of Solid-State Drive (SSD) with Random Access Memory (RAM). Notice that I didn’t compare the Hard Disk Drive (HDD) with the RAM because HDD is slower than SSD. An SSD like SAMSUNG 980 PRO (Pcle Gen4 SSD) has a sequential read/write speed of up to 7000 MB/s and 5,000 MB/s. On the other hand, theoretical the speed of RAM on a module of PC3-12800 memory can transfer 12,800 MB/s which faster than the real-world performance of an SSD (Lander, 2016).</p>
        <p>"However, in the real world, spending your money on an SSD may make more of a difference than adding RAM. The old rule that adding RAM improves performance breaks down when you already have enough RAM to do what you want. For many users, four to eight GB of memory provides excellent performance. At that point, swapping a relatively slow hard drive for a speedy SSD will make a noticeable difference in how quickly your computer boots up and how quickly programs open. If your operating system needs to use a page file, which is a chunk of your hard disk set aside as a bit of just-in-case memory, a page file stored on an SSD will also be faster" (Lander, 2016, para. 5).</p>
        <p>* Upgrading The Memory:</p>
        <p>According to Arpaci-Dusseau & Arpaci-Dusseau (2012), Since paging to secondary storage (disk) is expensive, the cost of frequent paging is prohibitive. The most simple and best solution to excessive paging is upgrading or buy more memory. I personally prefer to have at least 16 GB of physical memory in the machine.</p>
        <p>References</p>
        <p>Arpaci-Dusseau, R. H., & Arpaci-Dusseau, A. C. (2012). Operating Systems: Three Easy Pieces, Chapters 18-23. Madison, WI: Arpaci-Dusseau Books. Retrieved from <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/">Click Here</a></p>
        <p>Kerner, S. M. (2019, August 8). What is Memory Swapping? Retrieved from <a href="https://www.enterprisestorageforum.com/hardware/what-is-memory-swapping/">Click Here</a></p>
        <p>Lander, S. (2016, October 26). How does a Flash Drive's Memory Work? Retrieved March 15, 2021, from <a href="https://smallbusiness.chron.com/flash-drives-memory-work-65419.html">Click Here</a></p>
        <p>Simple Snippets. (2018, September 10). Paging in Operating Systems with Example & Working - Memory Management [Video]. YouTube. <a href="https://www.youtube.com/watch?v=pJ6qrCB8pDw">Click Here</a></p>
        <p style="color: red">The previous was written by Youssef Hassane, 15 March 2021</p>
      </div>
    </section>
  </main>
  <footer class="page__footer">
    <p>&copy Udacity</p>
  </footer>
  <script src="js/app.js"></script>
</body>
</html>
